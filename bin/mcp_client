#!/bin/bash

# Start an MCP client that connects to the distributed broker via STDIO
cd "$(dirname "$0")/.." || exit

# JWT Authentication Support
# Set MCP_CLIENT_JWT environment variable to provide a JWT token for authentication
# Example: export MCP_CLIENT_JWT="eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."
# 
# Generate tokens using: bin/generate_jwt SUBJECT TAGS [OPTIONS]
# Example: bin/generate_jwt claude-code "api,public,coding" --client-name "Claude Code"

if [ -n "$MCP_CLIENT_JWT" ]; then
    echo "Using JWT token from MCP_CLIENT_JWT environment variable" >&2
else
    echo "Warning: No JWT token found. Running in development mode with all access." >&2
    echo "To enable authentication, set MCP_CLIENT_JWT environment variable" >&2
fi

# Start epmd if not running (needed for distributed Erlang)
if ! pgrep -f epmd > /dev/null; then
    echo "Starting epmd (Erlang Port Mapper Daemon)..." >&2
    epmd -daemon
fi

# Start the client application which will handle STDIO communication
exec elixir --erl "+pc unicode" -e "
# Configure Logger to stderr BEFORE starting it
Application.put_env(:logger, :console, device: :standard_error)
Application.ensure_all_started(:logger)

# Compile and load modules (suppress output)
Mix.install([{:jason, \"~> 1.4\"}], verbose: false)

# Load our modules
Code.compile_file(\"lib/mcp_client/application.ex\")
Code.compile_file(\"lib/mcp_client/stdio_handler.ex\")

# Start the client application
Application.ensure_all_started(:crypto)
{:ok, _} = McpClient.Application.start(:normal, [])

# Keep the process alive
Process.sleep(:infinity)
"
